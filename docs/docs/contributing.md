---
sidebar_position: 8
title: "Contributing"
---

# Contributing

Thank you for your interest in contributing to mjml-java! This guide covers how to set up your development environment, run tests, and submit changes.

## Prerequisites

- **Java 17** or later (the project targets Java 17)
- **Maven 3.8+** (used for building and testing)
- **Git** for version control

## Building the Project

Clone the repository and build:

```bash
git clone https://github.com/jcputney/mjml-java.git
cd mjml-java
mvn clean verify
```

This compiles the source, runs all tests, and generates a JaCoCo code coverage report.

To build without running tests:

```bash
mvn clean package -DskipTests
```

## Running Tests

The project has 196 tests organized into two categories:

### Unit Tests (163 tests)

Standard JUnit 5 tests that verify individual components, parsing, CSS inlining, and utility functions:

```bash
mvn test
```

### Golden File Tests (33 tests)

These tests render MJML templates and compare the output against known-good HTML files generated by the official MJML v4 Node.js toolchain. They ensure compatibility with the MJML specification.

Golden test resources are located in:

```
src/test/resources/golden/
  ├── input/       # .mjml source files
  └── expected/    # .html expected output files
```

Each golden test:
1. Reads an MJML file from `input/`
2. Renders it to HTML using `MjmlRenderer.render()`
3. Compares the output against the corresponding file in `expected/`

### Adding a New Golden Test

1. Create your MJML template and save it as `src/test/resources/golden/input/my-test.mjml`
2. Generate the expected HTML using the official MJML CLI:
   ```bash
   npx mjml src/test/resources/golden/input/my-test.mjml -o src/test/resources/golden/expected/my-test.html
   ```
3. The test runner automatically picks up new files in the `input/` directory

## Project Structure

```
src/main/java/dev/jcputney/mjml/
├── MjmlRenderer.java          # Public API entry point
├── MjmlConfiguration.java     # Immutable configuration
├── MjmlRenderResult.java      # Render result record
├── MjmlException.java         # Base exception
├── IncludeResolver.java       # Include resolution interface
├── FileSystemIncludeResolver.java
├── component/
│   ├── BaseComponent.java     # Sealed base (BodyComponent | HeadComponent)
│   ├── BodyComponent.java     # Abstract body component
│   ├── HeadComponent.java     # Abstract head component
│   ├── ComponentFactory.java  # Factory functional interface
│   ├── ComponentRegistry.java # Tag-to-factory registry
│   ├── body/                  # Layout: MjBody, MjSection, MjColumn, etc.
│   ├── content/               # Content: MjText, MjImage, MjButton, etc.
│   ├── head/                  # Head: MjTitle, MjFont, MjAttributes, etc.
│   └── interactive/           # Interactive: MjHero, MjAccordion, etc.
├── context/
│   ├── GlobalContext.java     # Fonts, styles, attributes collected from head
│   ├── RenderContext.java     # Current container width during rendering
│   └── AttributeResolver.java # 5-level attribute cascade
├── css/
│   ├── CssInliner.java       # Standalone CSS inlining engine
│   ├── HtmlDocumentParser.java # Lightweight HTML parser
│   └── ...                    # CSS parser, selector matcher, etc.
├── parser/
│   ├── MjmlParser.java        # XML-based MJML parser
│   ├── MjmlPreprocessor.java  # CDATA wrapping for mixed content
│   ├── MjmlNode.java          # Parsed node tree
│   └── IncludeProcessor.java  # mj-include expansion
├── render/
│   ├── RenderPipeline.java    # 7-phase orchestrator
│   └── HtmlSkeleton.java     # HTML document skeleton assembly
└── util/
    ├── CssBoxModel.java       # Box model calculations
    ├── CssUnitParser.java     # CSS unit parsing
    └── SocialNetworkRegistry.java # Built-in social icon URLs
```

## Adding a New Component

### Body Component (renders HTML)

1. Create a new class in the appropriate package (`body/`, `content/`, or `interactive/`)
2. Extend `BodyComponent`
3. Implement the required methods:

```java
public class MjCustom extends BodyComponent {

  public MjCustom(MjmlNode node, GlobalContext globalContext, RenderContext renderContext) {
    super(node, globalContext, renderContext);
  }

  @Override
  public String getTagName() {
    return "mj-custom";
  }

  @Override
  public Map<String, String> getDefaultAttributes() {
    return Map.of(
        "padding", "10px 25px",
        "color", "#000000"
    );
  }

  @Override
  public String render() {
    // Build and return HTML string
    StringBuilder sb = new StringBuilder();
    sb.append("<div style=\"").append(buildStyle(getStyles())).append("\">");
    sb.append(renderChildren());
    sb.append("</div>");
    return sb.toString();
  }
}
```

4. Register the component in `RenderPipeline.createRegistry()`:
   ```java
   reg.register("mj-custom", MjCustom::new);
   ```

### Head Component (processes metadata)

1. Extend `HeadComponent`
2. Implement `process()` to update the `GlobalContext`:

```java
public class MjCustomHead extends HeadComponent {

  public MjCustomHead(MjmlNode node, GlobalContext globalContext, RenderContext renderContext) {
    super(node, globalContext, renderContext);
  }

  @Override
  public String getTagName() {
    return "mj-custom-head";
  }

  @Override
  public void process() {
    // Update globalContext with metadata from this component's attributes
  }
}
```

## Code Style

- Standard Java conventions (no external formatter enforced)
- Java 17 features are available (records, sealed classes, text blocks, etc.)
- **Note:** Pattern-matching `switch` on sealed types is **not** available in Java 17; use `if-else instanceof` chains instead
- Zero external runtime dependencies -- only JDK standard library
- Test dependencies: JUnit Jupiter 5

## Submitting Changes

1. Fork the repository
2. Create a feature branch from `main`
3. Make your changes with tests
4. Run the full test suite: `mvn clean verify`
5. Submit a pull request with a clear description of the changes

All pull requests should include appropriate test coverage. For new components, include at least a golden file test demonstrating the rendered output.
